# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Karnet BDD
                                 A QGIS plugin
 Ce plugin sert à valider les données brutes issue des données brutes Karum
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-24
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Jules-Yann Milleret - Karum/Éconumérik
        email                : jy.millleret@econumerik.fr
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QApplication, QFileDialog
from PyQt5.QtCore import QVariant
from qgis.core import Qgis, QgsMessageLog, QgsProject, QgsVectorLayer, QgsField, QgsFields, QgsFeature, QgsGeometry, QgsEditorWidgetSetup, QgsWkbTypes, QgsDataSourceUri, QgsCoordinateReferenceSystem, QgsSettings
from PyQt5.QtWidgets import QMessageBox
from shapely.wkb import loads
import processing
import psycopg2
import json
import datetime
import yaml
import pandas as pd


# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Karnet_dialog import KarnetDialog
import os.path


try :
    settings = QgsSettings()
    connection_name = 'lizmap_karum_carto'
    prefix = f"/qgis/connections/postgres/{connection_name}/"

    host = settings.value(prefix + "host", "")
    port = settings.value(prefix + "port", "")
    database = settings.value(prefix + "database", "")
    username = settings.value(prefix + "username", "")
    password = settings.value(prefix + "password", "")

    QgsMessageLog.logMessage("Lecture des informations de connexion réalisé avec succès.", 'Karnet', Qgis.Info)
except Exception as e :
    QgsMessageLog.logMessage("Il semble qu'une erreur se soit produite lors de la tentative de récupération des informations de connexion.", 'Karnet', Qgis.Info)
    raise ValueError("Il semble qu'une erreur se soit produite lors de la tentative de récupération des informations de connexion.")


def replace_null_values(dict):
    for key, value in dict.items():
        if value == '' or value == 'NULL':
            dict[key] = None
    return dict

def show_message_box(message):
    msg_box = QMessageBox()
    msg_box.setIcon(QMessageBox.Question)
    msg_box.setText(str(message))
    msg_box.setWindowTitle("Pause du script")
    msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
    
    # Afficher la pop-up et capturer la réponse
    return msg_box.exec_()


class Karnet:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Karnet_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)


        config = yaml.safe_load(open(os.path.join(os.path.dirname(__file__),'config.yaml'), 'r'))
        self.HOST = config.get('HOST')
        self.PORT = config.get('PORT')
        self.DBNAME = config.get('DBNAME')
        self.USER = config.get('USER')
        self.PASSWORD = config.get('PASSWORD')


        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Karnet BDD')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Karnet BDD', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToDatabaseMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = os.path.join(os.path.dirname(__file__),'public/favicon.png')
        self.add_action(
            icon_path,
            text=self.tr(u'Karnet BDD'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginDatabaseMenu(
                self.tr(u'&Karnet'),
                action)
            self.iface.removeToolBarIcon(action)


    """
    ##########################################################################################################
    ##########################################################################################################
    ####################################### Import des données Terrain #######################################
    ##########################################################################################################
    ##########################################################################################################
    """

############################################################################
############################################################################
############################################################################

    def createSession(self, layer, cur):
        QgsMessageLog.logMessage('Création de la session...', 'Karnet', Qgis.Info)
        attributs = next(layer.getFeatures()).attributes()
        attributs = dict(zip(layer.fields().names(), attributs))

        cur.execute(f"SELECT id FROM karum.observateur WHERE nom = %s;", (attributs['Obs_nom'],))
        obs = cur.fetchone()
        if obs is None:
            raise ValueError("Le nom d'utilisateur de la session n'existe pas en base de données, veuillez contactez l'administrateur de la base.")
        obs_id = obs[0]

        requete = f"""
        INSERT INTO karum.session 
        (affaire_id, uid, nom, date_export, departement_id, observateur_id) 
        VALUES
        ({attributs['Num_aff']}, '{str(attributs['uid_session'])}', '{attributs['Nom_sess']}', '{attributs['Date_exp'].toString("yyyy-MM-dd")}', {attributs['Departement']}, {obs_id})
        ;"""
        cur.execute(requete)
        requete = f"""SELECT id FROM karum.session WHERE uid = '{str(attributs['uid_session'])}'"""
        cur.execute(requete)
        return cur.fetchone()[0]


    def createTrace(self, layer, session_id, cur):
        QgsMessageLog.logMessage('Création des traces session...', 'Karnet', Qgis.Info)
        for entite in layer.getFeatures():
            attributs = entite.attributes()
            attributs = dict(zip(layer.fields().names(), attributs))
            geometrie = entite.geometry().asWkt()
            requete = f"""
            INSERT INTO karum.trace_session 
            (geometrie, precision_moyenne, altitude_moyenne, date, heure, longueur, session_id)
            VALUES
            ('{geometrie}', '{attributs['Preci_moy']}', '{attributs['Alt_moy']}', '{attributs['Date'].toString("yyyy-MM-dd")}', '{str(attributs['Debut'])}', '{attributs['Longueur']}', '{session_id}')
            ;"""
            cur.execute(requete)

    
    def createHabitat(self, layer, session_id, cur, layer_name):
        QgsMessageLog.logMessage('Création des habitats : '+layer_name+'...', 'Karnet', Qgis.Info)
        habitats = {}

        for entite in layer.getFeatures():
            attributs = entite.attributes()
            attributs = dict(zip(layer.fields().names(), attributs))
            attributs = replace_null_values(attributs)
            geometrie = entite.geometry().asWkt()

            if attributs['Nom_hab'] not in habitats :

                requete = f"""
                INSERT INTO karum.habitat_karnet
                (nom, commentaire, photo, commentaire_audio, session_id, affaire_id)
                VALUES
                (%s, %s, %s, %s, %s, %s)
                RETURNING id
                ;"""

                cur.execute(requete, (
                    attributs['Nom_hab'],
                    None if attributs['Comment'] == 'NULL' else str(attributs['Comment']),
                    None if attributs['Photo'] == 'NULL' else str(attributs['Photo']),
                    None if attributs['Comm_audio'] == 'NULL' else str(attributs['Comm_audio']),
                    session_id,
                    None if attributs['Num_aff'] == 'NULL' else attributs['Num_aff']
                ))

                habitat_id = cur.fetchone()[0]

                habitats.update({attributs['Nom_hab'] : habitat_id})

            if layer_name == '025_Habitats_P':
                type_geometrie = 'Point'
                automatique = True if attributs['Type_point'] == 'Point automatique' else False
            elif layer_name == '026_Habitats_S':
                type_geometrie = 'Polygone'

            habitat_id = habitats[attributs['Nom_hab']]

            requete = f"""
            INSERT INTO karum.zone_habitat
            (geometrie, type_geometrie, precision, altitude, surface, date, heure, automatique, habitat_id)
            VALUES
            (%s, %s, %s, %s, %s, %s, %s, %s, %s)
            ;"""
            cur.execute(requete, (
                geometrie,
                type_geometrie,
                attributs['Preci_moy'] if 'Preci_moy' in attributs else attributs['Precision'],
                attributs['Alt_moy'] if 'Alt_moy' in attributs else attributs['Altitude'],
                None if 'Surface' not in attributs else attributs['Surface'],
                str(attributs['Date'].toString("dd-MM-yyyy")),
                str(attributs['Heure']),
                False if 'Type_point' not in attributs else automatique,
                habitat_id
            ))

        return habitats


    def createProtocole(self, layer, session_id, cur, layer_name):
        QgsMessageLog.logMessage('Création des protocoles : '+layer_name+'...', 'Karnet', Qgis.Info)
        protocoles = {}
        if layer_name == '002_Protocole_IPA_Repasse_P' :
            type = 'Avifaune'
            type_geometrie = 'Point'
        elif layer_name == '003_Protocole_Rhopalo_P' :
            type = 'Lepidoptere'
            type_geometrie = 'Point'
        elif layer_name == '004_Protocole_Rhopalo_L' :
            type = 'Lepidoptere'
            type_geometrie = 'Ligne'
        elif layer_name == '005_Protocole_Chiro_P' :
            type = 'Chiroptere'
            type_geometrie = 'Point'

        def insert_protocole():
            requete = f"""
            INSERT INTO karum.protocole 
            (nom, type, date, absence_observation, debut, fin, ciel, vent, temperature, comment, photo, comm_audio, affaire_id, session_id)
            VALUES
            (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
            ;"""
            cur.execute(requete, (
                attributs['Nom_proto'],
                type,
                str(attributs['Date'].toString("dd-MM-yyyy")),
                True if attributs['Obs_abs'] == "VRAI" else False,
                None if attributs['Debut'] == 'NULL' else str(attributs['Debut']),
                None if attributs['Fin'] == 'NULL' else str(attributs['Fin']),
                None if attributs['Ciel'] == 'NULL' else str(attributs['Ciel']),
                None if attributs['Vent'] == 'NULL' else str(attributs['Vent']),
                None if str(attributs['Temperature']) == 'NULL' else str(attributs['Temperature']),
                None if attributs['Comment'] == 'NULL' else str(attributs['Comment']),
                None if attributs['Photo'] == 'NULL' else str(attributs['Photo']),
                None if attributs['Comm_audio'] == 'NULL' else str(attributs['Comm_audio']),
                None if attributs['Num_aff'] == 'NULL' else attributs['Num_aff'],
                session_id
            ))
            protocole_id = cur.fetchone()[0]

            protocoles.update({attributs['Nom_proto'] : protocole_id})
            ### Check si les protocoles ont un nom unique

            requete = """
            INSERT INTO karum.geometrie_protocole 
            (geometrie, type_geometrie, precision, altitude, longueur, date, heure, protocole_id)
            VALUES
            (%s, %s, %s, %s, %s, %s, %s, %s)
            ;"""
            cur.execute(requete, (
                geometrie,
                type_geometrie,
                attributs['Preci_moy'] if 'Preci_moy' in attributs else attributs['Precision'],
                attributs['Alt_moy'] if 'Alt_moy' in attributs else attributs['Altitude'],
                None if 'Longueur' not in attributs else attributs['Longueur'],
                str(attributs['Date'].toString("dd-MM-yyyy")),
                str(attributs['Debut']),
                protocole_id
            ))
            return protocoles

        for entite in layer.getFeatures():
            attributs = entite.attributes()
            attributs = dict(zip(layer.fields().names(), attributs))
            attributs = replace_null_values(attributs)
            geometrie = entite.geometry().asWkt()

            if layer_name == '004_Protocole_Rhopalo_L' :

                cur.execute(f"""SELECT nom, id FROM karum.protocole WHERE session_id = {session_id} AND type = 'Lepidoptere'""")
                proto = cur.fetchall()

                proto = {key: value for key, value in proto}

                if attributs['Nom_proto'] not in proto.keys() :
                    insert_protocole()
                else :
                    protocole_id = proto[attributs['Nom_proto']]
                    requete = """
                    INSERT INTO karum.geometrie_protocole 
                    (geometrie, type_geometrie, precision, altitude, longueur, date, heure, protocole_id)
                    VALUES
                    (%s, %s, %s, %s, %s, %s, %s, %s)
                    ;"""
                    cur.execute(requete, (
                        geometrie,
                        type_geometrie,
                        attributs['Preci_moy'] if 'Preci_moy' in attributs else attributs['Precision'],
                        attributs['Alt_moy'] if 'Alt_moy' in attributs else attributs['Altitude'],
                        None if 'Longueur' not in attributs else attributs['Longueur'],
                        str(attributs['Date'].toString("dd-MM-yyyy")),
                        str(attributs['Debut']),
                        protocole_id
                    ))
            else :
                insert_protocole()
        return protocoles

    def my_function(self, df):
        return {'Repro' : str(df['Repro'])}


    def createBrute(self, layer, session_id, cur, layer_name, protocoles, habitat):
        QgsMessageLog.logMessage('Création des données espèces brutes : '+layer_name+'...', 'Karnet', Qgis.Info)
        errors = {}
        for entite in layer.getFeatures():
            attributs = entite.attributes()
            attributs = dict(zip(layer.fields().names(), attributs))
            attributs = replace_null_values(attributs)
            geometrie = entite.geometry().asWkt()

            protocole_id = None
            habitat_id = None
            if 'Obs_method' in attributs :
                if 'Nom_proto' in attributs and attributs['Obs_method'] != 'Opportuniste':
                    protocole_id = protocoles[attributs['Nom_proto']]

            if 'Nom_hab' in attributs:
                habitat_id = habitat[attributs['Nom_hab']]

            if layer_name == '006_Avifaune_P' :
                type_taxon = 'Avifaune'
                type_geometrie = 'Point'
            elif layer_name == '007_Lepidopteres_P' :
                type_taxon = 'Lepidoptere'
                type_geometrie = 'Point'
            elif layer_name == '008_Lepidopteres_L' :
                type_taxon = 'Lepidoptere'
                type_geometrie = 'Ligne'
            elif layer_name == '009_Chiropteres_P' :
                type_taxon = 'Chiroptere'
                type_geometrie = 'Point'
            elif layer_name == '010_Amphibiens_P' :
                type_taxon = 'Amphibien'
                type_geometrie = 'Point'
            elif layer_name == '011_Coleopteres_P' :
                type_taxon = 'Coleoptere'
                type_geometrie = 'Point'
            elif layer_name == '012_Mammiferes_hc_P' :
                type_taxon = 'Mammifere'
                type_geometrie = 'Point'
            elif layer_name == '013_Odonates_P' :
                type_taxon = 'Odonate'
                type_geometrie = 'Point'
            elif layer_name == '014_Orthopteres_P' :
                type_taxon = 'Orthoptere'
                type_geometrie = 'Point'
            elif layer_name == '015_Reptiles_P' :
                type_taxon = 'Reptile'
                type_geometrie = 'Point'
            elif layer_name == '016_Plantes_hotes_P' :
                type_taxon = 'Plante Hote'
                type_geometrie = 'Point'
            elif layer_name == '017_Plantes_hotes_L' :
                type_taxon = 'Plante Hote'
                type_geometrie = 'Ligne'
            elif layer_name == '018_Plantes_hotes_S' :
                type_taxon = 'Plante Hote'
                type_geometrie = 'Polygone'
            elif layer_name == '019_Elements_divers_P' :
                type_taxon = 'Element divers'
                type_geometrie = 'Point'
            elif layer_name == '020_Elements_divers_L' :
                type_taxon = 'Element divers'
                type_geometrie = 'Ligne'
            elif layer_name == '021_Elements_divers_S' :
                type_taxon = 'Element divers'
                type_geometrie = 'Polygone'
            elif layer_name == '022_Flore_patrimoniale_P' :
                type_taxon = 'Flore patrimoniale'
                type_geometrie = 'Point'
            elif layer_name == '023_Flore_patrimoniale_L' :
                type_taxon = 'Flore patrimoniale'
                type_geometrie = 'Ligne'
            elif layer_name == '024_Flore_patrimoniale_S' :
                type_taxon = 'Flore patrimoniale'
                type_geometrie = 'Polygone'
            elif layer_name == '027_Especes_habitat_P' :
                type_taxon = 'Espece habitat'
                type_geometrie = 'Point'
            elif layer_name == '028_Especes_habitat_S' :
                type_taxon = 'Espece habitat'
                type_geometrie = 'Polygone'

            specifique = {}
            cles = {'Repro':'reproduction', 'Stade_vie':'stade_vie', 'Comport':'comportement', 'Nb_couple':'nombre_couples', 'echantillon':'echantillon', 'strate_arboree':'strate_arboree', 'strate_arbustive':'strate_arbustive', 'strate_herbacee':'strate_herbacee', 'strate_muscinale':'strate_muscinale',
                    'Echant':'echantillon', 'Ind_abon':'indice_abondance', 'identification':'identification', 'Type_milieu':'type_milieu', 'Detail':'detail'}
            for cle in cles.keys() : 
                if cle in attributs :
                    valeur = attributs[cle]
                    if isinstance(valeur, QVariant) :
                        if not valeur.isNull() :
                            specifique.update({cles[cle] : str(attributs[cle])})
                    else :
                        specifique.update({cles[cle] : attributs[cle]})
                    
            specifique = json.dumps(dict(specifique), ensure_ascii=False)


            if layer_name in ['008_Lepidopteres_L', '024_Flore_patrimoniale_S', '028_Especes_habitat_S', '021_Elements_divers_S', '020_Elements_divers_L', '018_Plantes_hotes_S']:
                type_point = 'Point manuel'
                precision = 'Preci_moy'
                altitude = 'Alt_moy'
            else :
                type_point = None if attributs['Type_point'] == 'NULL' else str(attributs['Type_point'])
                precision = 'Precision'
                altitude = 'Altitude'


            requete = """
            INSERT INTO karum.karnet_b 
            (type, geometrie, type_geometrie, date, heure, cd_nom, nom_hors_taxref, type_point, precision, altitude, methode_observation, doute, nombre_total,
            specifique, commentaire, photo, commentaire_audio, affaire_id, session_id, protocole_id, habitat_id, observateur_id)
            VALUES
            (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            RETURNING id
            ;"""


            cur.execute(f"SELECT id FROM karum.observateur WHERE nom = %s;", (attributs['Obs_nom'],))

            obs_id = cur.fetchone()[0]
            if obs_id is None:
                raise ValueError("Il semble que le nom d'utilisateur de la session n'existe pas en Base de données, veuillez contactez l'administrateur de la base.")


            try :
                cur.execute("SAVEPOINT savepoint_before_insert;")

                cur.execute(requete, (
                    type_taxon,
                    geometrie,
                    type_geometrie,
                    str(attributs['Date'].toString("dd-MM-yyyy")),
                    None if attributs['Heure'] == 'NULL' else str(attributs['Heure']),
                    None if 'Cd_nom' not in attributs else None if attributs['Cd_nom'] == None else str(attributs['Cd_nom']),
                    str(attributs['Nom']) if 'Nom' in attributs else str(attributs['Nom_vern'] if 'Nom_vern' in attributs else str(attributs['Nom_scien'])),
                    type_point,
                    None if attributs[precision] == 'NULL' else attributs[precision],
                    None if attributs[altitude] == 'NULL' else attributs[altitude],
                    None if 'Obs_method' not in attributs else None if attributs['Obs_method'] == 'NULL' else str(attributs['Obs_method']),
                    True if attributs['Doute'] == "VRAI" else False,
                    None if 'Nombre' not in attributs else None if attributs['Nombre'] == 'NULL' else attributs['Nombre'],
                    specifique,
                    None if attributs['Comment'] == 'NULL' else str(attributs['Comment']),
                    None if attributs['Photo'] == 'NULL' else str(attributs['Photo']),
                    None if attributs['Comm_audio'] == 'NULL' else str(attributs['Comm_audio']),
                    attributs['Num_aff'],
                    session_id,
                    protocole_id,
                    habitat_id,
                    obs_id
                ))
            except :
                errors.update({type_taxon : attributs['fid']})
                QgsMessageLog.logMessage(str(errors), 'Karnet', Qgis.Warning)
                cur.execute("ROLLBACK TO SAVEPOINT savepoint_before_insert;")

        return errors




############################################################################
############################################################################
############################################################################

    def saveDatas(self, layers):
        iterateur_valeurs = iter(layers.values())

        conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        cur = conn.cursor()
        try :
            id_session = self.createSession(next(iterateur_valeurs), cur)
            errors = self.redirectCreation(layers, id_session, cur)

            if len(errors) > 0 :
                errors = "\n".join([f"{key} : {value}" for key, value in errors.items()])

                response = show_message_box("Les entités suivantes ne peuvent pas être ajoutées : " + '\n' + str(errors) + '\n' + "Voulez-vous poursuivre sans intégrer ces données ?")

                if response == QMessageBox.No :
                    raise ValueError("L'intégration a été interrompue par l'utilisateur.")

            conn.commit()
            self.iface.messageBar().pushMessage('Karnet', "La session à bien été enregistré.", level=Qgis.Success)
            QgsMessageLog.logMessage("La session à bien été enregistré.", 'Karnet', Qgis.Success)
        except Exception as e :
            self.iface.messageBar().pushMessage('Karnet', "La session n'a pas été créé : "+str(e), level=Qgis.Critical)
            QgsMessageLog.logMessage("La session n'a pas été créé : "+str(e), 'Karnet', Qgis.Critical)
            conn.rollback()
        finally:
            conn.close()
            self.update_combobox(self.dlg.cbxSession, self.sessions())
            self.update_combobox(self.dlg.cbxAffaire, self.affaires())



    def redirectCreation(self, layers, session_id, cur):
        protocole = {}
        habitat = {}
        errors = {}

        order = ['001_Session_L', '002_Protocole_IPA_Repasse_P', '003_Protocole_Rhopalo_P', '004_Protocole_Rhopalo_L', '005_Protocole_Chiro_P', 
                '025_Habitats_P', '026_Habitats_S', '006_Avifaune_P', '007_Lepidopteres_P', '008_Lepidopteres_L',
                '009_Chiropteres_P', '010_Amphibiens_P', '011_Coleopteres_P', '012_Mammiferes_hc_P', '013_Odonates_P',
                '014_Orthopteres_P', '015_Reptiles_P', '016_Plantes_hotes_P', '017_Plantes_hotes_L', '018_Plantes_hotes_S',
                '019_Elements_divers_P', '020_Elements_divers_L', '021_Elements_divers_S',
                '022_Flore_patrimoniale_P', '023_Flore_patrimoniale_L', '024_Flore_patrimoniale_S', '027_Especes_habitat_P', '028_Especes_habitat_S']
        
        try :
            for layer_name in order :
                if layer_name in layers :
                    if layer_name in ['001_Session_L'] :
                        self.createTrace(layers[layer_name], session_id, cur)

                    elif layer_name in ['002_Protocole_IPA_Repasse_P', '003_Protocole_Rhopalo_P', '004_Protocole_Rhopalo_L', '005_Protocole_Chiro_P']:
                        protocole.update(self.createProtocole(layers[layer_name], session_id, cur, layer_name))
                    
                    elif layer_name in ['025_Habitats_P', '026_Habitats_S']:
                        habitat.update(self.createHabitat(layers[layer_name], session_id, cur, layer_name))

                    elif layer_name in ['006_Avifaune_P', '007_Lepidopteres_P', '008_Lepidopteres_L',
                                '009_Chiropteres_P', '010_Amphibiens_P', '011_Coleopteres_P', '012_Mammiferes_hc_P', '013_Odonates_P',
                                '014_Orthopteres_P', '015_Reptiles_P', '016_Plantes_hotes_P', '017_Plantes_hotes_L',
                                '018_Plantes_hotes_S', '019_Elements_divers_P', '020_Elements_divers_L', '021_Elements_divers_S',
                                '022_Flore_patrimoniale_P', '023_Flore_patrimoniale_L', '024_Flore_patrimoniale_S', '027_Especes_habitat_P', '028_Especes_habitat_S']:
                        errors.update(self.createBrute(layers[layer_name], session_id, cur, layer_name, protocole, habitat))
        except Exception as e :
            self.iface.messageBar().pushMessage('Karnet', "La session n'a pas été enregistrer, consultez le journal d'erreurs pour plus d'informations.", level=Qgis.Critical)
            raise ValueError(str(e))
        finally :
            return errors






############################################################################
############################################################################
############################################################################


    def onpbChoisirCheminTabletteClicked(self): #Ouverture d'un explorateur pour sélectionner un gpkg existant
        filename, _filter = QFileDialog.getOpenFileName(
            self.dlg, "Sélectionner un GPKG ","", "Geopackage (*.gpkg)")
        self.dlg.leCheminGpkgTablette.setText(filename)


    def layersNamesAreValids(self, path):
        accepted_layers = ['001_Session_L', '002_Protocole_IPA_Repasse_P', '003_Protocole_Rhopalo_P', '004_Protocole_Rhopalo_L',
                    '005_Protocole_Chiro_P', '006_Avifaune_P', '007_Lepidopteres_P', '008_Lepidopteres_L',
                    '009_Chiropteres_P', '010_Amphibiens_P', '011_Coleopteres_P', '012_Mammiferes_hc_P', '013_Odonates_P',
                    '014_Orthopteres_P', '015_Reptiles_P', '016_Plantes_hotes_P', '017_Plantes_hotes_L',
                    '018_Plantes_hotes_S', '019_Elements_divers_P', '020_Elements_divers_L', '021_Elements_divers_S',
                    '022_Flore_patrimoniale_P', '023_Flore_patrimoniale_L', '024_Flore_patrimoniale_S', '025_Habitats_P',
                    '026_Habitats_S', '027_Especes_habitat_P', '028_Especes_habitat_S']
        
        gpkg = QgsVectorLayer(path, "", "ogr")

        layers_datas = gpkg.dataProvider().subLayers()
        for layer_data in layers_datas:
            name = layer_data.split('!!::!!')[1]
            if name.lower() not in [name.lower() for name in accepted_layers]:
                self.iface.messageBar().pushMessage('Karnet', "La couche : "+name+" n'est pas une couche valide, le nom de la couche est incorrect.", level=Qgis.Critical)
                QgsMessageLog.logMessage('La couche : '+name+" n'est pas une couche valide, le nom de la couche est incorrect. (UID déjà présent en BDD)", 'Karnet', Qgis.Critical)
                return False
        return True

    def uidSessionsAreValids(self, layers):
        uids_couche = []
        for name, layer in layers.items():
            for entite in layer.getFeatures():
                attributs = entite.attributes()
                attributs = dict(zip(layer.fields().names(), attributs))
                if attributs['uid_session'] not in uids_couche:
                    uids_couche.append(attributs['uid_session'])

        if len(uids_couche) > 1:
            self.iface.messageBar().pushMessage('Karnet', "La session contient plusieurs UID différent", level=Qgis.Critical)
            QgsMessageLog.logMessage("La session contient plusieurs UID différent", 'Karnet', Qgis.Critical)
            return False
        else :
            conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
            cur = conn.cursor()
            cur.execute(f"SELECT session.uid FROM karum.session WHERE uid = '{uids_couche[0]}'")
            if cur.fetchall():
                self.iface.messageBar().pushMessage('Karnet', "La session est déjà stocké en BDD.", level=Qgis.Critical)
                QgsMessageLog.logMessage("La session est déjà stocké en BDD", 'Karnet', Qgis.Critical)
                return False
            else :
                return True



    def onpbIntegrerTabletteClicked(self): # Integration des données
        stop = 0

        self.dlg.pbIntegrerTablette.setEnabled(False)
        self.dlg.pbIntegrerTablette.setText("Intégration en cours")
        # QCoreApplication.processEvents()

        # Récupération du chemin du gpkg :
        path = self.dlg.leCheminGpkgTablette.text()
        gpkg = QgsVectorLayer(path, "", "ogr")


        # Vérification de la validité des noms de couches
        if self.layersNamesAreValids(path):
            QgsMessageLog.logMessage("Les noms des couches sont valides", 'Karnet', Qgis.Success)

            # Création de la bibliothèque avec les couches du gpkg
            layers = {}
            layers_datas = gpkg.dataProvider().subLayers()
            for layer_data in layers_datas:
                name = layer_data.split('!!::!!')[1]
                layer = QgsVectorLayer(path+'|layername='+name, "", "ogr")
                layers.update({name : layer})

            # Vérification de l'UID
            if self.uidSessionsAreValids(layers) == True:
                QgsMessageLog.logMessage("L'UID de la session est valide", 'Karnet', Qgis.Success)
                self.saveDatas(layers)
        else :
            QgsMessageLog.logMessage("Le geopackage contient une couche avec un nom invalide.", 'Karnet', Qgis.Critical)

        self.dlg.pbIntegrerTablette.setEnabled(True)



        # if stop == 0 :
        #     for name, layer in layers.items() :
        #         if layer.isValid():
        #             # Boucler sur les entités de la couche
        #             for entite in layer.getFeatures():
        #                 attributs = entite.attributes()
        #                 attributs = dict(zip(layer.fields().names(), attributs))
        #         else :
        #             QgsMessageLog.logMessage('La couche : '+name+" n'est pas une couche valide, elle n'a pas été intégré. (Erreur Karnet.py:265 : UID déjà présent en BDD)", 'Karnet', Qgis.Critical)
        # else :
        #     QgsMessageLog.logMessage("Les couches n'ont pas été intégré. (Erreur Karnet.py:267 : UID déjà présent en BDD)", 'Karnet', Qgis.Critical)


    """
    ##########################################################################################################
    ##########################################################################################################
    ######################################### Validation des données #########################################
    ##########################################################################################################
    ##########################################################################################################
    """

    def validIntegration(self, layer, layername):

        if layer.geometryType() == QgsWkbTypes.PointGeometry:
            type_geometrie = "Point"
        elif layer.geometryType() == QgsWkbTypes.LineGeometry:
            type_geometrie = "Ligne"
        elif layer.geometryType() == QgsWkbTypes.PolygonGeometry:
            type_geometrie = "Polygone"
        else:
            raise ValueError("la géométrie de la couche est inconnue, contactez un administrateur.")

        conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        cur = conn.cursor()

        try :

            for entite in layer.getFeatures():
                attributs = entite.attributes()
                attributs = dict(zip(layer.fields().names(), attributs))

                requete = f"""SELECT * FROM karum.karnet_b WHERE id = {attributs['id']};"""

                # Récupération des infos de la données brutes

                cur.execute(requete)
                result = cur.fetchone()

                col_names = [desc[0] for desc in cur.description]
                result = dict(zip(col_names, result))

                requete = f"""
                    INSERT INTO karum.karnet_v
                    (type, geometrie, type_geometrie, date, heure, cd_nom, type_point, longueur, surface, precision, altitude, methode_observation, doute, nombre_total, specifique,
                    statut_validation, commentaire, photo, commentaire_audio, affaire_id, session_id, protocole_id, habitat_id, observateur_id, karnet_b_id)
                    VALUES
                    (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ;"""

                spec_col = ['nymphe', 'stade_inde', 'repro', 'adulte', 'comport_nr', 'actif', 'chant_spon', 'chant', 'comport', 'femelle', 'mort', 'emergence',
                            'sans_rep', 'stade_nr', 'ponte', 'ind_abon', 'stade_vie', 'male', 'oeuf', 'vol_local', 'en_chasse', 'strate_arbustive', 'echantillon',
                            'juvenile', 'en_transit', 'strate_muscinale', 'halte_mig', 'strate_herbacee', 'vu', 'strate_arboree', 'tetard', 'para_nupt', 'vol_mig',
                            'cri', 'nidif', 'strate', 'exuvie', 'reponse', 'juvenile_non_volant', 'stade_vie_non_renseigne', 'nb_total', 'accoupl', 'mobbing',
                            'reproduction', 'larve', 'en_ponte', 'déf_terr', 'strate_arboree']
            
                specifique = {}
                for spec in spec_col:
                    if spec in attributs :
                        specifique[spec] = str(attributs[spec])
                specifique = json.dumps(specifique, ensure_ascii=False)


                cur.execute(requete, (
                    layername,
                    entite.geometry().asWkt(),
                    str(type_geometrie),
                    attributs['date'],
                    str(attributs['heure']),
                    attributs['cd_nom'],
                    result['type_point'],
                    None if 'longueur' not in attributs or attributs['longueur'] == 'NULL' else attributs['altitude'],
                    None if 'surface' not in attributs or attributs['surface'] == 'NULL' else attributs['surface'],
                    None if 'precision' not in attributs or attributs['precision'] == 'NULL' else attributs['precision'],
                    None if 'altitude' not in attributs or attributs['altitude'] == 'NULL' else attributs['altitude'],
                    str(attributs['methode_observation']),
                    attributs['doute'],
                    attributs['nb_total'] if 'nb_total' in attributs else attributs['nombre_total'],
                    specifique,
                    str(attributs['stat_val']),
                    str(attributs['commentaire']),
                    str(attributs['photo']),
                    str(attributs['commentaire_audio']),
                    attributs['num_aff'],
                    result['session_id'],
                    result['protocole_id'],
                    result['habitat_id'],
                    result['observateur_id'],
                    attributs['id']
                ))

            conn.commit()
            self.iface.messageBar().pushMessage('Karnet', f"La couche {layername} à bien été intégré aux données validées.", level=Qgis.Success)
            QgsMessageLog.logMessage(f"La couche {layername} à bien été intégré aux données validées.", 'Karnet', Qgis.Success)

        except Exception as e :
            QgsMessageLog.logMessage("Erreur lors de l'execution de la requête pour intégrer la données : " + str(e), 'Karnet', Qgis.Info)

        finally :
            conn.close()


    def check(self, layer, layername):
        sql=processing.run("qgis:postgisexecuteandloadsql", {'DATABASE':'Lizmap','SQL':'SELECT DISTINCT karnet_b_id FROM karum.karnet_v;', 'ID_FIELD':'karnet_b_id','GEOMETRY_FIELD':''})['OUTPUT']
        id_validated = []
        for feature in sql.getFeatures() :
            id_validated.append(feature['karnet_b_id'])


        for entite in layer.getFeatures():
            attributs = entite.attributes()
            attributs = dict(zip(layer.fields().names(), attributs))
            
            if attributs['id'] in id_validated :
                raise ValueError(f"L'entité {attributs['id']} à déjà été validé.")

        if layername == 'Element divers' :
            for key in ['id', 'num_aff', 'nom_sess', 'altitude', 'date', 'heure', 'doute', 'nombre_total', 'obs_nom', 'cd_nom', 'stat_val']:
                if key == 'doute' and attributs[key] == 'vrai':
                    raise ValueError(f"le champs {key} de l'entité {attributs['id']} est Vrai.")
                if attributs[key] in ['NULL', '', None] :
                    raise ValueError(f"le champs {key} de l'entité {attributs['id']} est NULL.")
        else :
            for key in ['id', 'num_aff', 'nom_sess', 'altitude', 'date', 'heure', 'nom_complet', 'nom_vern', 'doute', 'nombre_total', 'obs_nom', 'cd_nom', 'stat_val']:
                if key == 'doute' and attributs[key] == 'vrai':
                    raise ValueError(f"le champs {key} de l'entité {attributs['id']} est Vrai.")
                if attributs[key] in ['NULL', '', None] :
                    raise ValueError(f"le champs {key} de l'entité {attributs['id']} est NULL.")
                
        QgsMessageLog.logMessage("La couches est valide.", 'Karnet', Qgis.Success)

        

    def onValidationClicked(self):
        layer = self.dlg.cbxValidation.currentData()
        layer_name = self.dlg.cbxValidation.currentText()

        try :
            self.check(layer, layer_name)
            self.validIntegration(layer, layer_name)
        except Exception as e: # Erreur si la requête ne renvoie rien
            QgsMessageLog.logMessage(str(e), 'Karnet', Qgis.Info)
            self.iface.messageBar().pushMessage('Karnet', "La couche n'a pas été validée :" + str(e), level=Qgis.Warning)





    """
    ##########################################################################################################
    ##########################################################################################################
    ######################################### Extractions des données ########################################
    ##########################################################################################################
    ##########################################################################################################
    """


####################################################################################
############################ Création des couches ##################################
####################################################################################

    def createTempLayers(self, requete, type_couche, type_geometrie):
        item_iter = 0

        type = {
            'bool': QVariant.Bool,
            'object': QVariant.String,
            'int64': QVariant.Int,
            'float64': QVariant.Double,
            1082: QVariant.Date,
            1083: QVariant.Time,
        }

        conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        cur = conn.cursor()

        cur.execute(requete)

        result = cur.fetchall()

        # if len(result) < 1 :
        #     raise ValueError("Pas d'entité dans cette couche.")

        colinfo = [(desc.name, desc.type_code) for desc in cur.description]
        colname = [desc.name for desc in cur.description]

        df = pd.DataFrame(result, columns=colname)

        if len(result) > 0:

            if type_geometrie == 'Point':
                layer = QgsVectorLayer("Point?crs=EPSG:2154", type_couche, "memory")
            elif type_geometrie == 'Ligne' :
                layer = QgsVectorLayer("LineString?crs=EPSG:2154", type_couche, "memory")
            elif type_geometrie == 'Polygone' :
                layer = QgsVectorLayer("Polygon?crs=EPSG:2154", type_couche, "memory")


            pr = layer.dataProvider()

            fields = QgsFields()
            for column in df.columns :
                if column == 'specifique':
                    keys = set()
                    for json_dict in df['specifique']:
                        if json_dict is not None :
                            keys.update(json_dict.keys())
                    for key in keys :
                        fields.append(QgsField(key, QVariant.String))
                else :
                    fields.append(QgsField(column, type[str(df[column].dtype)]))
            pr.addAttributes(fields)
            layer.updateFields()
            

            # Ajout des entités à la couche
            for row in df.itertuples(index=False):
                item_iter += 1
                feature = QgsFeature()
                feature.setFields(layer.fields())

                for field_name, field_value in zip(df.columns, row):
                    if field_name == "geometrie":  # Si c'est la géométrie
                        # Créer un objet de géométrie à partir des données géométriques
                        if field_value != None :
                            geom = QgsGeometry.fromWkt(str(loads(bytes.fromhex(field_value))))
                            feature.setGeometry(geom)
                        else :
                            QgsMessageLog.logMessage(f'Une geometrie de la couche : {type_couche} est NULL', 'Karnet', Qgis.Warning)
                    elif field_name == 'specifique':
                        if field_value is not None :
                            for cle, valeur in field_value.items() :
                                feature.setAttribute(cle, str(valeur))
                    elif field_value in ['NULL', 'None', 'NUL', 'nan'] or field_value is None :
                        feature.setAttribute(field_name, None)
                    elif field_name in ['date'] or isinstance(field_value, datetime.datetime):
                        feature.setAttribute(field_name, str(field_value))
                    else:
                        # Définir les autres attributs de l'entité
                        feature.setAttribute(field_name, field_value)

                if feature.isValid():
                    success, added_features = layer.dataProvider().addFeatures([feature])
                    if not success:
                        QgsMessageLog.logMessage("Impossible d'ajouter l'entité : " + str(feature.attributes()), 'Karnet', Qgis.Critical)
                else:
                    QgsMessageLog.logMessage('Invalid feature: ' + str(feature.attributes()), 'Karnet', Qgis.Warning)

            QgsProject.instance().addMapLayer(layer)

            QgsMessageLog.logMessage(str(item_iter) + " entités on été ajouté à la couche.", 'Karnet', Qgis.Info)


    def createMemoryLayers(self, requete, type_couche, type_geometrie) :
        uri = QgsDataSourceUri()
        #uri.setConnection(self.HOST, self.PORT, self.DBNAME, self.USER, self.PASSWORD)
        uri = f"dbname={self.DBNAME} host={self.HOST} port={self.PORT} user={self.USER} password={self.PASSWORD}"

        try :
            check = processing.run("qgis:postgisexecuteandloadsql", {'DATABASE':'Lizmap','SQL':requete,'ID_FIELD':'id','GEOMETRY_FIELD':''})['OUTPUT']

            if check.featureCount() > 0:
                layer = processing.run("qgis:postgisexecuteandloadsql", {'DATABASE':'Lizmap','SQL':requete,'ID_FIELD':'id','GEOMETRY_FIELD':'geometrie'})['OUTPUT']
                layer.setName(type_couche)
                layer.setCrs(QgsCoordinateReferenceSystem("EPSG:2154"))
                QgsProject.instance().addMapLayer(layer)  
        except Exception as e :
            raise ValueError(str(e))



    def getLayers(self, parametres):
        for type_couche, type_geometries in parametres:
                for type_geometrie in type_geometries:
                    QgsMessageLog.logMessage('Récupération de la couche ' + type_couche + ' - ' + type_geometrie, 'Karnet', Qgis.Info)
                    requete = self.requeteDonneeBrute(type_couche, type_geometrie)
                    QgsMessageLog.logMessage('Requête : ' + requete, 'Karnet', Qgis.Info)
                    if self.dlg.rbValide.isChecked():
                        self.createMemoryLayers(requete, type_couche, type_geometrie)
                    else :
                        self.createTempLayers(requete, type_couche, type_geometrie)

        layers = QgsProject.instance().mapLayers().values()

        self.dlg.cbxValidation.clear()
        for layer in layers:
            self.dlg.cbxValidation.addItem(layer.name(), layer)


##########################################################################################################
############################## Récupération des données depuis la bdd ####################################
##########################################################################################################

############### Requêtes données spécifiques espèces #####################

    def getFiltre(self, table):
        if self.dlg.cbxSession.currentData():
            return f"""AND {table}.session_id = {self.dlg.cbxSession.currentData()}"""
        elif self.dlg.cbxAffaire.currentData():
            return f"""AND {table}.affaire_id = {self.dlg.cbxAffaire.currentData()}"""
        elif self.dlg.cbxObservatoire.currentData():
            return f"""AND {table}.affaire_id = {self.dlg.cbxObservatoire.currentData()}"""
        elif self.dlg.cbxObservateur.currentData():
            return f""""""
        else :
            return ""
    
    def getValidationTable(self):
        if self.dlg.rbValide.isChecked():
            return 'karnet_v'
        else :
            return 'karnet_b'

    def getAvifauneSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        
        filtre = self.getFiltre(table)

        specifique = """specifique->>'Repro' AS Repro, specifique->>'Adulte' AS Adulte, specifique->>'Male' AS Male, specifique->>'Femelle' AS Femelle,
    specifique->>'Juv_vol' AS Juvenile_volant, specifique->>'Juv_n_vol' AS Juvenile_non_volant, specifique->>'\u0152uf' AS Oeuf, specifique->>'Stade_inde' AS Stade_inde,
    specifique->>'Stade_nr' AS Stade_nr, specifique->>'Nb_couples' AS Nb_couples, specifique->>'Nb_total' AS Nb_total, specifique->>'Chant' AS Chant, specifique->>'Cri' AS Cri,
    specifique->>'Vol_local' AS Vol_local, specifique->>'Pose' AS Pose, specifique->>'Nidif' AS Nidif, specifique->>'Para_nupt' AS Para_nupt,
    specifique->>'D\u00e9f_terr' AS D\u00e9f_terr, specifique->>'En_chasse' AS En_chasse, specifique->>'Vol_mig' AS Vol_mig, specifique->>'Halte_mig' AS Halte_mig,
    specifique->>'Mort' AS Mort, specifique->>'Comport_nr' AS Comport_nr, specifique->>'Chant_spon' AS Chant_spon, specifique->>'Reponse' AS Reponse,
    specifique->>'Sans_rep' AS Sans_rep, specifique->>'Vu' AS Vu, specifique->>'Mobbing' AS Mobbing"""
    
        return self.getRequeteBase(table, type_couche, type_geometrie)

    def getAmphibienSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'Repro' AS Repro, specifique->>'Adulte' AS Adulte, specifique->>'Male' AS Male, specifique->>'Femelle' AS Femelle, specifique->>'Tetard' AS Tetard,
        specifique->>'Ponte' AS Ponte, specifique->>'Juvenile' AS Juvenile, specifique->>'Emergent' AS Emergent, specifique->>'Stade_nr' AS Stade_nr, specifique->>'Comport' AS Comport"""

        return self.getRequeteBase(table, type_couche, type_geometrie)

    def getLepidoptereSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'Repro' AS Repro, specifique->>'Stade_vie' AS Stade_vie, specifique->>'Ind_abon' AS Ind_abon, specifique->>'Nb_total' AS Nb_total,
        specifique->>'Actif' AS Actif, specifique->>'En_transit' AS En_transit, specifique->>'Accoupl' AS Accoupl, specifique->>'En_ponte' AS En_ponte,
        specifique->>'Emergence' AS Emergence, specifique->>'Mort' AS Mort, specifique->>'Comport_nr' AS Comport_nr"""
        
        return self.getRequeteBase(table, type_couche, type_geometrie)
    
    def getColeoptereSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'reproduction' AS reproduction, specifique->>'adulte' AS adulte, specifique->>'male' AS male, specifique->>'femelle' AS femelle,
        specifique->>'larve' AS larve, specifique->>'nymphe' AS nymphe, specifique->>'oeuf' AS oeuf, specifique->>'stade_vie_non_renseigne' AS stade_vie_non_renseigne,
        specifique->>'comportement' AS comportement"""

        return self.getRequeteBase(table, type_couche, type_geometrie)
    
    def getOrthoptereSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'reproduction' AS reproduction, specifique->>'adulte' AS adulte, specifique->>'male' AS male, specifique->>'femelle' AS femelle,
        specifique->>'larve' AS larve, specifique->>'nymphe' AS nymphe, specifique->>'stade_vie_non_renseigne' AS stade_vie_non_renseigne, specifique->>'comportement' AS comportement"""

        return self.getRequeteBase(table, type_couche, type_geometrie)
    
    def getMammifereSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'reproduction' AS reproduction, specifique->>'adulte' AS adulte, specifique->>'male' AS male, specifique->>'femelle' AS femelle,
        specifique->>'juvenile' AS juvenile, specifique->>'stade_vie_non_renseigne' AS stade_vie_non_renseigne, specifique->>'comportement' AS comportement"""

        return self.getRequeteBase(table, type_couche, type_geometrie)

    def getOdonateSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'reproduction' AS reproduction, specifique->>'adulte' AS adulte, specifique->>'male' AS male, specifique->>'femelle' AS femelle,
        specifique->>'larve' AS larve, specifique->>'exuvie' AS exuvie, specifique->>'stade_vie_non_renseigne' AS stade_vie_non_renseigne, specifique->>'comportement' AS comportement"""

        return self.getRequeteBase(table, type_couche, type_geometrie)

    def getReptileSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'reproduction' AS reproduction, specifique->>'adulte' AS adulte, specifique->>'male' AS male, specifique->>'femelle' AS femelle,
        specifique->>'juvenile' AS juvenile, specifique->>'mue' AS mue, specifique->>'stade_vie_non_renseigne' AS stade_vie_non_renseigne, specifique->>'comportement' AS comportement"""

        return self.getRequeteBase(table, type_couche, type_geometrie)

    def getFlorePatrimonaleSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'Echant' AS echantillon"""

        return self.getRequeteBase(table, type_couche, type_geometrie)

    def getEspeceHabitatSpecifique(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)
        specifique = """specifique->>'echantillon' AS echantillon, specifique->>'strate_arboree' AS strate_arboree, specifique->>'strate_arbustive' AS strate_arbustive, specifique->>'strate_herbacee' AS strate_herbacee, specifique->>'strate_muscinale' AS strate_muscinale"""

        return self.getRequeteBase(table, type_couche, type_geometrie)
    
    def getDivers(self, type_couche, type_geometrie):
        table = self.getValidationTable()
        filtre = self.getFiltre(table)

        return self.getRequeteBase(table, type_couche, type_geometrie, filtre)


    def requeteDonneeBrute(self, type_couche, type_geometrie):
        if type_couche in ['Protocole Avifaune', 'Protocole Lepidoptere', 'Protocole Chiroptere']:
            return self.getProtocole(type_couche)
        elif type_couche in ['Habitat']:
            return self.getHabitat(type_geometrie)
        elif type_couche in ['Trace session']:
            return self.getTraceSession()
        else :
            table = self.getValidationTable()
            if table == 'karnet_v':
                return f"""SELECT
                    {table}.id,
                    {table}.geometrie,
                    {table}.affaire_id AS num_aff,
                    CASE
                    WHEN session.nom IS NOT NULL THEN session.nom
                    ELSE karnet_v.ancienne_donnee->>'Nom_sess'
                    END AS nom_sess,
                    {table}.altitude,
                    CASE
                    WHEN {table}.date IS NOT NULL THEN {table}.date
                    WHEN protocole.date IS NOT NULL THEN protocole.date
                    ELSE NULL
                    END AS date,
                    {table}.heure,
                    {table}.methode_observation,
                    protocole.nom AS nom_proto,
                    {table}.cd_nom,
                    taxref.nom_complet,
                    taxref.nom_vern,
                    {table}.doute,
                    {table}.nombre_total,
                    {table}.specifique,
                    observateur.nom AS obs_nom,
                    {table}.statut_validation AS stat_val,
                    lrn.code_statut AS LRN,
                    {table}_lrr.code_statut AS LRR,
                    protection_nationale.code_statut AS PN,
                    interet_communautaire.cd_statut AS IC,
                    {table}.commentaire,
                    {table}.photo,
                    {table}.commentaire_audio
                    FROM karum.{table}
                    LEFT JOIN karum.taxref ON taxref.cd_nom = {table}.cd_nom
                    LEFT JOIN karum.session ON session.id = {table}.session_id
                    LEFT JOIN karum.protocole ON protocole.id = {table}.protocole_id
                    LEFT JOIN karum.observateur ON observateur.id = {table}.observateur_id
                    LEFT JOIN karum.lrn ON {table}.cd_nom = lrn.cd_nom
                    LEFT JOIN karum.{table}_lrr ON {table}.id = {table}_lrr.id
                    LEFT JOIN karum.protection_nationale ON {table}.cd_nom = protection_nationale.cd_nom
                    LEFT JOIN karum.interet_communautaire ON karum.interet_communautaire.cd_nom = {table}.cd_nom
                    WHERE {table}.type = '{type_couche}' AND type_geometrie = '{type_geometrie}' {self.getFiltre(table)};"""
            
            if table == 'karnet_b':
                return f"""SELECT
                    {table}.id,
                    {table}.geometrie,
                    {table}.affaire_id AS num_aff,
                    session.nom AS nom_sess,
                    {table}.altitude,
                    CASE
                    WHEN {table}.date IS NOT NULL THEN {table}.date
                    WHEN protocole.date IS NOT NULL THEN protocole.date
                    ELSE NULL
                    END AS date,
                    {table}.heure,
                    {table}.methode_observation,
                    protocole.nom AS nom_proto,
                    {table}.cd_nom,
                    taxref.nom_complet,
                    taxref.nom_vern,
                    {table}.nom_hors_taxref,
                    {table}.doute,
                    {table}.nombre_total,
                    {table}.specifique,
                    observateur.nom AS obs_nom,
                    {table}.statut_validation AS stat_val,
                    lrn.code_statut AS LRN,
                    {table}_lrr.code_statut AS LRR,
                    protection_nationale.code_statut AS PN,
                    interet_communautaire.cd_statut AS IC,
                    {table}.commentaire,
                    {table}.photo,
                    {table}.commentaire_audio
                    FROM karum.{table}
                    LEFT JOIN karum.taxref ON taxref.cd_nom = {table}.cd_nom
                    LEFT JOIN karum.session ON session.id = {table}.session_id
                    LEFT JOIN karum.protocole ON protocole.id = {table}.protocole_id
                    LEFT JOIN karum.observateur ON observateur.id = {table}.observateur_id
                    LEFT JOIN karum.lrn ON {table}.cd_nom = lrn.cd_nom
                    LEFT JOIN karum.{table}_lrr ON {table}.id = {table}_lrr.id
                    LEFT JOIN karum.protection_nationale ON {table}.cd_nom = protection_nationale.cd_nom
                    LEFT JOIN karum.interet_communautaire ON karum.interet_communautaire.cd_nom = {table}.cd_nom
                    WHERE {table}.type = '{type_couche}' AND type_geometrie = '{type_geometrie}' {self.getFiltre(table)};"""


############### Requêtes données autres #####################

    def getProtocole(self, type_couche):
        couche = ''
        if type_couche == 'Protocole Avifaune':
            couche = 'Avifaune'
        elif type_couche == 'Protocole Lepidoptere':
            couche = 'Lepidoptere'
        if type_couche == 'Protocole Chiroptere':
            couche = 'Chiroptere'
        return f"""SELECT 
                protocole.id,
                session.affaire_id,
                geometrie_protocole.geometrie,
                session.nom AS "session",
                protocole.nom AS protocole,
                protocole.date,
                protocole.debut,
                protocole.fin,
                protocole.absence_observation,
                geometrie_protocole.altitude,
                protocole.ciel,
                protocole.vent,
                protocole.temperature,
                protocole.Comment,
                protocole.Photo,
                protocole.Comm_audio,
                observateur.nom AS observateur
                FROM karum.protocole 
                JOIN karum.geometrie_protocole ON protocole.id = geometrie_protocole.protocole_id 
                JOIN karum.session ON session.id = protocole.session_id
                JOIN karum.observateur ON observateur_id = observateur.id WHERE type='{couche}' {self.getFiltre('protocole')};"""

    def getHabitat(self, type_geometrie):
        return f"""SELECT zone_habitat.id, zone_habitat.geometrie, session.affaire_id, session.nom AS nom_sess, habitat_karnet.nom as nom_habitat, zone_habitat.precision, zone_habitat.altitude, zone_habitat.surface, zone_habitat.date,
            zone_habitat.heure, habitat_karnet.commentaire, habitat_karnet.photo, habitat_karnet.commentaire_audio, habitat_karnet.session_id, session.departement_id
            FROM karum.habitat_karnet
            LEFT JOIN karum.zone_habitat ON habitat_karnet.id = zone_habitat.habitat_id 
            LEFT JOIN karum.session ON session.id = habitat_karnet.session_id 
            WHERE type_geometrie = '{type_geometrie}'{self.getFiltre('habitat_karnet')};"""
        
    def getTraceSession(self):
        return f"""
        SELECT 
        trace_session.id, trace_session.geometrie, trace_session.session_id, trace_session.precision_moyenne AS precision,
        trace_session.altitude_moyenne AS altitude, trace_session.date, trace_session.longueur, session.nom AS session, session.affaire_id, observateur.nom AS observateur
        FROM karum.trace_session
        JOIN karum.session ON session_id = session.id
        JOIN karum.observateur ON observateur_id = observateur.id
        WHERE session_id = {self.dlg.cbxSession.currentData()};"""

###############################################################################################
############### Redirection vers les fonctions correspondants aux boutons #####################
###############################################################################################

    def onpbExtractClicked(self): # Selection des couches et redirection vers script données brutes ou validées
        try :
            self.dlg.pbExtract.setEnabled(False)
            QApplication.processEvents()

    # Récupération des données espèces    
            # Choix du type de couche (Avifaune, Amphibiens,...)
            parametres = []
            if self.dlg.cbAvifaune.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Avifaune', ['Point']))
            if self.dlg.cbAmphibien.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Amphibien', ['Point']))
            if self.dlg.cbLepidoptere.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Lepidoptere', ['Point', 'Ligne']))
            if self.dlg.cbColeoptere.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Coleoptere', ['Point']))
            if self.dlg.cbOrthoptere.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Orthoptere', ['Point']))
            if self.dlg.cbMammifere.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Mammifere', ['Point']))
            if self.dlg.cbOdonate.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Odonate', ['Point', 'Ligne']))
            if self.dlg.cbReptile.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Reptile', ['Point']))
            if self.dlg.cbFlorePat.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Flore patrimoniale', ['Point', 'Ligne', 'Polygone']))
            if self.dlg.cbEspHab.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Espece habitat', ['Point', 'Ligne', 'Polygone']))
            if self.dlg.cbProtoAvi.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Protocole Avifaune', ['Point']))
            if self.dlg.cbProtoLepi.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Protocole Lepidoptere', ['Point', 'Ligne']))
            if self.dlg.cbProtoChiro.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Protocole Chiroptere', ['Point']))
            if self.dlg.cbPlantesHotes.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Plante Hote', ['Point', 'Ligne', 'Polygone']))

            if self.dlg.cbHabitats.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Habitat', ['Point', 'Ligne', 'Polygone']))
            if self.dlg.cbTrace.isChecked() or self.dlg.allDatas.isChecked():
                if self.dlg.cbxSession.currentData():
                    parametres.append(('Trace session', ['Ligne']))
                else :
                    raise ValueError("Impossible de récupérer une trace sans session. Merci de renseigner le champ session.")
            if self.dlg.cbDivers.isChecked() or self.dlg.allDatas.isChecked():
                parametres.append(('Element divers', ['Point', 'Ligne', 'Polygone']))
        except Exception as e :
            self.iface.messageBar().pushMessage('Karnet', str(e), level=Qgis.Critical)
            QgsMessageLog.logMessage(str(e), 'Karnet', Qgis.Critical)
    
        self.getLayers(parametres)

        self.dlg.pbExtract.setEnabled(True)

        self.iface.messageBar().pushMessage('Karnet', "La récupération des données c'est déroulé avec succès.", level=Qgis.Success)
        QgsMessageLog.logMessage("La récupération des données c'est déroulé avec succès.", 'Karnet', Qgis.Success)


    """
    ##########################################################################################################
    ##########################################################################################################
    ######################################### Création d'une affaire #########################################
    ##########################################################################################################
    ##########################################################################################################
    """


    def addAffaire(self):
        conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        cur = conn.cursor()

        try :
            num_affaire = int(self.dlg.num_affaire.text())
            nom_affaire = str(self.dlg.nom_affaire.text())
            observatoire_id = self.dlg.cbxObservatoireAffaire.currentData()

            if num_affaire == '' or num_affaire is None :
                raise ValueError("Le numéro d'affaire est manquant.")
            
            if nom_affaire == '' or nom_affaire is None :
                raise ValueError("Le nom de l'affaire est manquant.")

            if not 1000000 < num_affaire < 9999999 :
                raise ValueError("Le numéro d'affaire n'a pas le bon format.")
            
            cur.execute(f"SELECT * FROM karum.affaire WHERE id = {num_affaire}")
            if cur.fetchall():
                raise ValueError("Le numéro d'affaire existe déjà.")
            
            if observatoire_id :
                cur.execute(f"""INSERT INTO karum.affaire (id, nom, observatoire_id) VALUES ({num_affaire}, '{nom_affaire}', '{observatoire_id}');""")
                conn.commit()
            else :
                cur.execute(f"""INSERT INTO karum.affaire (id, nom) VALUES ({num_affaire}, '{nom_affaire}');""")
                conn.commit()

            self.iface.messageBar().pushMessage('Karnet', f"L'affaire {num_affaire} à été créée avec succès.", level=Qgis.Success)
        except Exception as e :
            self.iface.messageBar().pushMessage('Karnet', f"L'affaire {num_affaire} n'a pas été créée. Consultez le journal des messages pour plus de détails.", level=Qgis.Warning)
            QgsMessageLog.logMessage("L'affaire n'a pas été créée : " + str(e), 'Karnet', Qgis.Warning)
        finally :
            self.update_combobox(self.dlg.cbxAffaire, self.affaires())
            conn.close()


    """
    ##########################################################################################################
    ##########################################################################################################
    ######################################### Création des habitats ##########################################
    ##########################################################################################################
    ##########################################################################################################
    """

    def createMinimalEmptyHabitatLayer(self):
        # conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        # cur = conn.cursor()

        # cur.execute("SELECT * FROM karum.")

        fields = QgsFields()
        fields.append(QgsField('Code EUNIS', QVariant.String))
        fields.append(QgsField('Label EUNIS', QVariant.String))
        fields.append(QgsField('Interet communautaire', QVariant.Double))
        fields.append(QgsField('Zone_humide_K', QVariant.Double))
        fields.append(QgsField('Enjeu', QVariant.Int))
        fields.append(QgsField('Surface', QVariant.String))

        layer = QgsVectorLayer("Polygon?crs=EPSG:2154", 'Habitat minimal', 'memory')
        pr = layer.dataProvider()

        pr.addAttributes(fields)
        layer.updateFields()

        layer.setEditorWidgetSetup(layer.fields().indexOf('Code EUNIS'), QgsEditorWidgetSetup('ValueMap', {
            'map': {'Option1': 'Option1', 'Option2': 'Option2', 'Option3': 'Option3'}
        }))

        QgsProject.instance().addMapLayer(layer)

        # def update_fields_based_on_type(layer, feature_id):
        #     feature = layer.getFeature(feature_id)
        #     zone_type = feature['Code EUNIS']
        #     layer.startEditing()
        #     if zone_type == 'Option1':
        #         feature['Enjeu'] = 11
        #     elif zone_type == 'Option2':
        #         feature['Enjeu'] = 12
        #     elif zone_type == 'Option3':
        #         feature['Enjeu'] = 13
        #     layer.updateFeature(feature)
        #     layer.commitChanges()


        def feature_added_callback(fid):
            update_fields_based_on_type(layer, fid)

        layer.featureAdded.connect(feature_added_callback)

        # def update_fields_based_on_type(feature):
        #     zone_type = feature['Code EUNIS']
        #     feature.setAttribute('Enjeu', 11)
        #     if zone_type == 'Option1':
        #         feature.setAttribute('Label EUNIS', 'Description pour Option1')
        #     elif zone_type == 'Option2':
        #         feature.setAttribute('Label EUNIS', 'Description pour Option2')
        #     elif zone_type == 'Option3':
        #         feature.setAttribute('Label EUNIS', 'Description pour Option3')

        # # Étape 4: Connecter l'événement d'ajout de fonctionnalités
        # def on_feature_added(feature_id):
        #     feature = layer.getFeature(feature_id)
        #     update_fields_based_on_type(feature)
        #     pr.addFeature(feature)
        #     layer.updateExtents()

        # layer.featureAdded.connect(on_feature_added)


    def createTotalEmptyHabitatLayer(self):

        fields = QgsFields()
        fields.append(QgsField('Code EUNIS 1', QVariant.String))
        fields.append(QgsField('Pourcentage EUNIS 1', QVariant.String))
        fields.append(QgsField('Code EUNIS 2', QVariant.String))
        fields.append(QgsField('Pourcentage EUNIS 2', QVariant.String))
        fields.append(QgsField('Label EUNIS 3', QVariant.String))
        fields.append(QgsField('Interet communautaire', QVariant.Double))
        fields.append(QgsField('Zone_humide_K', QVariant.Double))
        fields.append(QgsField('Enjeu', QVariant.Int))
        fields.append(QgsField('Surface', QVariant.String))

        layer = QgsVectorLayer("Polygon?crs=EPSG:2154", 'Habitat complet', 'memory')
        pr = layer.dataProvider()

        pr.addAttributes(fields)
        layer.updateFields()

        layer.startEditing()
        QgsProject.instance().addMapLayer(layer)
        # Enregistrer les modifications
        layer.commitChanges()


    def validateHabitatsLayer(self) :
        pass
        layer = self.dlg.selectCoucheHabitatToValidate.currentData()
        layer_name = self.dlg.selectCoucheHabitatToValidate.currentText()

        data = []

        if layer_name == 'Habitat minimal' :
            for entite in layer.getFeatures():
                code_eunis = entite['Code Eunis']
                label_eunis = entite['Label Eunis']
                ic = entite['interet communautaire']
                zh_k = entite['Zone_humide_K']
                surface = entite['Surface']
                geometrie = entite.geometry().asWkt()

                data.append((code_eunis, label_eunis, ic, zh_k, surface, geometrie))


        elif layer_name == 'Habitat complet' :
            pass
        else :
            pass
            # raise Error
    

##########################################################################################################
##########################################################################################################
##########################################################################################################
##########################################################################################################

    def onClickedObservatoire(self): #Affaire values filtred by observatory on observatory clicked
        self.update_combobox(self.dlg.cbxAffaire, self.affaires(self.dlg.cbxObservatoire.currentData()))
        self.update_combobox(self.dlg.cbxSession, self.sessions(self.dlg.cbxObservatoire.currentData()))


    def update_combobox(self, combobox, dictio, empty=True):
        combobox.clear()
        if empty :
            combobox.addItem('', None)
        for id, nom in dictio:
            combobox.addItem(nom, id)

    def update_layers_combobox(self):
        layers = QgsProject.instance().mapLayers().values()

        self.dlg.cbxValidation.clear()
        for layer in layers:
            self.dlg.cbxValidation.addItem(layer.name(), layer)

    def observatoires(self):
        conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        cur = conn.cursor()
        cur.execute("SELECT affaire.id, affaire.nom FROM karum.affaire WHERE type_observatoire IS NOT NULL ORDER BY id;")
        observatoires = cur.fetchall()
        conn.close()
        return observatoires
    

    def affaires(self, observatoire_id = None):
        conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        cur = conn.cursor()
        if observatoire_id is None :
            cur.execute("SELECT affaire.id, affaire.id || ' - ' || affaire.nom FROM karum.affaire WHERE type_observatoire IS NULL ORDER BY affaire.id DESC;")
        else :
            cur.execute(f"SELECT affaire.id, affaire.id || ' - ' || affaire.nom FROM karum.affaire WHERE observatoire_id = {observatoire_id} ORDER BY affaire.id DESC;")
        affaires = cur.fetchall()
        conn.close()
        return affaires
    

    def sessions(self, affaire_id = None):
        conn = psycopg2.connect(host=self.HOST, port=self.PORT, dbname=self.DBNAME, user=self.USER, password=self.PASSWORD)
        cur = conn.cursor()
        if affaire_id is None :
            cur.execute("SELECT session.id, session.nom FROM karum.session left JOIN karum.affaire ON session.affaire_id = affaire.id ORDER BY session.nom;")
        else :
            cur.execute(f"SELECT session.id, session.nom FROM karum.session left JOIN karum.affaire ON session.affaire_id = affaire.id WHERE affaire_id = {affaire_id}")
        sessions = cur.fetchall()
        conn.close()
        return sessions
        


    def run(self): # Review : Idée pour accelerer le redémarage du plugin : créer des fonctions pour la récupération des données.
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = KarnetDialog()

            # Ajout des observatoires aux combobox
            self.update_combobox(self.dlg.cbxObservatoireAffaire, self.observatoires())
            self.update_combobox(self.dlg.cbxObservatoire, self.observatoires())
            self.update_combobox(self.dlg.cbxAffaire, self.affaires())
            self.update_combobox(self.dlg.cbxSession, self.sessions())


        # Déconnexion des signaux à chaque lancement du plugin
        try :
            self.dlg.pbExtract.disconnect()
            self.dlg.cbxObservatoire.disconnect()
            self.dlg.cbxAffaire.disconnect()
            self.dlg.pbChoisirCheminTablette.disconnect()
            self.dlg.createMinimalCoucheHabitat.disconnect()
            self.dlg.createTotalCoucheHabitat.disconnect()
            self.dlg.integreCoucheHabitat.disconnect()
            self.dlg.pbIntegrerValide.disconnect()
            self.dlg.pbIntegrerTablette.disconnect()
            self.dlg.leCheminGpkgTablette.disconnect()
        except :
            pass

        ### Extraction de données

        # Au click sur une combobox
        self.dlg.cbxObservatoire.currentIndexChanged.connect(self.onClickedObservatoire)
        self.dlg.cbxAffaire.currentIndexChanged.connect(lambda index: self.update_combobox(self.dlg.cbxSession, self.sessions(self.dlg.cbxAffaire.currentData())))

        # Désactivation années/observateurs
        self.dlg.cbxAnnee.setEnabled(False)
        self.dlg.cbxObservateur.setEnabled(False)

        #self.master_checkbox.stateChanged.connect(self.toggle_checkboxes)


        ### Ajout des données Terrain en BDD
        self.dlg.pbChoisirCheminTablette.clicked.connect(self.onpbChoisirCheminTabletteClicked)
        self.dlg.pbIntegrerTablette.clicked.connect(self.onpbIntegrerTabletteClicked)


        ### Validation des données
        layers = QgsProject.instance().mapLayers().values()

        self.dlg.cbxValidation.clear()
        for layer in layers:
            self.dlg.cbxValidation.addItem(layer.name(), layer)
            self.dlg.selectCoucheHabitatToValidate.addItem(layer.name(), layer)


        ### Création d'une nouvelle couche habitat
        self.update_combobox(self.dlg.selectSessionHabitat, self.sessions())


        # Bouton d'exécution
        self.dlg.createMinimalCoucheHabitat.clicked.connect(self.createMinimalEmptyHabitatLayer)
        self.dlg.createTotalCoucheHabitat.clicked.connect(self.createTotalEmptyHabitatLayer)
        self.dlg.integreCoucheHabitat.clicked.connect(self.validateHabitatsLayer)
        self.dlg.pbIntegrerValide.clicked.connect(self.onValidationClicked)
        self.dlg.pbExtract.clicked.connect(self.onpbExtractClicked)
        self.dlg.addAffaire.clicked.connect(self.addAffaire)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass
